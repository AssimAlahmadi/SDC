/*

	*Exploratory Data Analysis (EDA) on Sales Data*

Objective: To perform exploratory data analysis (EDA) on a given dataset and derive meaningful insights.
Date: 19/11/2024
From: SDC App



	*Personal Information*

Name: Assim Alharbi
Email: alahmadiassim@gmail.com
Phone: +966 531191626
*/

-- Columns "order_id, date_format, city and branch" where all unmerged using Excel,
-- and All the NULL values from the same columns where solved using the Power Query feature "Fill Down" in Excel.
-- All data types were adjusted when importing, and column names with spaces where changed.

-- Rename the date_format column as it appears to have the name of a function and might cause confusion
EXEC sp_rename 'sales.date_format', 'order_date', 'COLUMN';

-- Finding if any product name is associated with different categories
WITH products_mapping AS (
SELECT DISTINCT product_name, product_category
FROM sales
WHERE product_category IS NOT NULL

)

SELECT *
FROM products_mapping as mp
JOIN products_mapping as mp2
ON mp.product_name = mp2.product_name
WHERE mp.product_name = mp2.product_name AND
mp.product_category <> mp2.product_category

-- Handling all NULL values in the product_category column
WITH products_mapping AS (
SELECT DISTINCT product_name, product_category
FROM sales
WHERE product_category IS NOT NULL

)

UPDATE sales
SET product_category = (
SELECT pm.product_category
FROM products_mapping pm
WHERE pm.product_name = sales.product_name
)
WHERE product_category IS NULL;

-- Checking to see if all NULL values in product_category are handled
SELECT *
FROM sales
WHERE product_category IS NULL

-- Checking if the order_date column has any inconsistency
SELECT *
From sales
Order By order_date DESC

-- As a result of the previous query two orders came up with unrealistic dates:

-- 1. '2030-12-12 23:20:05.000'
/* This date is problematic as both the year and month are off,
which suggests it's either an error or generated by a system glitch (likely not a data entry mistake)*/
-- So, I can either remove the order, or set a default date (Averge or any other date).

-- I will remove the entire order, with all it's rows
DELETE FROM sales
WHERE order_date = '2030-12-12 23:20:05.000'


-- 2. '2030-05-08 01:25:53.000'
/*This date is more reasonable as it falls within the same months as other entries (April and May)
but has an unrealistic year (2030). 
Given that the month and day are consistent with other valid entries,
this seems more like a data entry error, which can be corrected.*/

-- I will adjust the year back to (2021)
UPDATE sales
SET order_date = '2021-05-08 01:25:53.000'
WHERE order_date = '2030-05-08 01:25:53.000'


-- Checking if the city column has any inconsistency
SELECT DISTINCT city
From sales

-- We have empty cells, let's check if those records have empty branch also
SELECT city, branch
From sales
WHERE city = ''

-- As the branch is not empty, we can use mapping to fill in the cells
WITH city_branch AS (
SELECT DISTINCT city, branch
FROM sales
WHERE city <> '' and branch <> ''
)

UPDATE sales
SET city = (
SELECT city
FROM city_branch as cb
WHERE cb.branch =  sales.branch
)
WHERE city = ''

-- Checking if any city value is still missing
SELECT DISTINCT city
FROM sales
-- All good

-- Now we move to the branch column, as we saw in the output there's also missing values in here
SELECT DISTINCT branch
From sales

-- Let's check which ones are missing
SELECT order_id, order_date, city, branch
From sales
WHERE branch = ''

-- As we can see both the orders with the missing branches are in Jeddah,
-- With Jeddah having 3 different branches (Unlike Makkah and Taif),
-- We have to decide what to do with these missing values:
-- 1. We can find the branch with the highest amount of orders and choose as a default.
-- 2. We can create another value like N/A for missing values.
-- 3. We can delete the rows as they might skew our analysis.

-- As the missing values here are only 10 rows which won't skew the analysis,
-- I will go with the first approach, and choose a default branch

-- Finding the branch with the most orders
SELECT branch, COUNT( DISTINCT order_id) as num_of_orders
FROM sales
WHERE city = 'Jeddah'
GROUP BY branch
ORDER BY num_of_orders DESC

-- Now we replace the missing values with the branch with the most orders
UPDATE sales
SET branch = (
SELECT TOP 1 branch
FROM sales
WHERE city = 'Jeddah'
GROUP BY branch
ORDER BY COUNT( DISTINCT order_id) DESC
)
WHERE branch = ''

-- Checking if the product_category column has any inconsistency
SELECT DISTINCT product_category
FROM sales

-- Checking if the product_name column has any inconsistency
SELECT DISTINCT product_name
FROM sales
Order By product_name

-- Checking if the quantity column has any inconsistency
SELECT DISTINCT quantity
FROM sales
Order By quantity DESC
-- The numbers (110) and (100) seems high, but not to the point of being outliers.

-- Checking if the total column has any inconsistency
SELECT  total
FROM sales 
ORDER BY total DESC

-- Before going any further, we need to create a column to price items
ALTER TABLE sales
ADD product_price FLOAT;

-- Add values to the column
UPDATE sales
SET product_price = (
total / quantity
)

-- Checking if the order_total column has any inconsistency
SELECT  order_total
FROM sales 
ORDER BY order_total

-- There is NULL values

-- Let's check which ones are NULL
SELECT *
FROM sales
WHERE order_total IS NULL


-- Before going further and changing the NULL values,
-- we need to do some calculations to better understand this column,
-- since it doesn't make any since at first glance, we need to better
-- understand how these results came up.

-- Lets create a new calculated column to count the total for each order

-- But first, We need to rename the order_total column to discounted_total for more readability
EXEC sp_rename 'sales.order_total', 'discounted_total', 'COLUMN'

-- Now lets create the new calculated column as order_total
ALTER TABLE sales
ADD order_total float;

-- Now we add values to the order_total column
WITH add_real_total AS (
SELECT order_id, quantity, product_price, total, SUM(total) OVER (PARTITION BY order_id ORDER BY order_id) as sum_order_total, discounted_total, order_total
FROM sales
)

UPDATE sales
SET order_total = art.sum_order_total
FROM sales as s
JOIN add_real_total as art
ON art.order_id = s.order_id

-- Now we see what type of discount was applied to the discounted_total
SELECT *, round((100 - discounted_total/ order_total * 100),2) as discount
FROM sales
ORDER BY discount


-- So, after some basic calculations, it seems that a discount
-- has been applied to the discounted_total,
-- (66.67%) seems to be the discount amount,
-- with only 4 orders not meeting that.

-- Order Id (479602) has different discounted_total across different rows which shouldn't be the case
-- This could have multiple reasons, one way of fixing this is manually by choosing the last value (76)
-- Which is the only correct discounted_total value of this order based on the discount percentage.
UPDATE sales
SET discounted_total = 76
WHERE order_id = '479602'

-- Another way to do this is to do some calculations,
-- and then update the wrong entries based on the outcomes.
-- Let's try this on the other order ids which have wrong discounted_total
WITH discount_cte AS (
SELECT *, ROUND((100 - discounted_total/ order_total * 100),2) as discount
FROM sales
)

UPDATE sales 
SET discounted_total = (s.order_total - (s.order_total * 0.6667))
FROM sales s
JOIN discount_cte as d
ON d.order_id = s.order_id
WHERE discount <> 66.67
-- All done


-- Now let's change the rows with Null values in the discounted_total
UPDATE sales
SET discounted_total = (order_total - (order_total * 0.6667))
FROM sales
WHERE sales.discounted_total IS NULL

-- Let's check everything one last time
SELECT *
FROM sales

-- Now I believe the data is ready for analysis,
-- Let's dive in!






--1. Descriptive Analysis:

SELECT * 
FROM sales

-- Number of orders
SELECT COUNT(DISTINCT order_id) as number_of_orders
FROM sales

-- Number of items purchased
SELECT SUM(quantity) as number_of_items
FROM sales

-- Number of orders per month
SELECT CASE WHEN MONTH(order_date) = 4 THEN 'April'
ELSE 'May'
END as month_of_year
, count(DISTINCT order_id) as number_of_orders
FROM sales
GROUP BY MONTH(order_date)
ORDER BY number_of_orders DESC

-- Number of orders per city
SELECT city, COUNT(DISTINCT order_id) as number_of_orders
FROM sales
GROUP BY city
ORDER BY number_of_orders DESC

-- Number of orders per branch
SELECT city, branch, COUNT(DISTINCT order_id) as number_of_orders
FROM sales
GROUP BY city, branch
ORDER BY number_of_orders DESC

-- Percentage of orders per branch
SELECT city, branch, COUNT(DISTINCT order_id) AS orders_per_branch,
CAST(ROUND(COUNT(DISTINCT order_id) * 100.0 / SUM(COUNT(DISTINCT order_id)) OVER (),2) AS decimal(5,2)) AS percentage_of_total
FROM sales
GROUP BY city, branch
ORDER BY percentage_of_total DESC

-- Most purchased item
SELECT product_name, COUNT(product_name) as number_of_orders, SUM(quantity) as quantity_of_items
FROM sales
GROUP BY product_name
ORDER BY quantity_of_items DESC


-- Number of orders per category, and number of items per category
SELECT product_category, COUNT(DISTINCT order_id) as number_of_orders, SUM(quantity) as quantity_of_items
FROM sales
GROUP BY product_category
ORDER BY number_of_orders DESC

-- Percentage of orders per category
SELECT product_category, COUNT(DISTINCT order_id) as number_of_orders,
CAST(ROUND(COUNT(DISTINCT order_id) * 100.0 / SUM(COUNT(DISTINCT order_id)) OVER (),2) AS decimal(5,2)) AS percentage_of_total
FROM sales
GROUP BY product_category
ORDER BY number_of_orders DESC

-- The Price of each item
SELECT DISTINCT product_category, product_name, product_price
FROM sales
ORDER BY product_name

-- Max, Min, and average prices per category
SELECT product_category, MAX(product_price) as max, MIN(product_price) as min, ROUND(AVG(product_price),2) as avg
FROM sales
GROUP BY product_category;

-- Total before and after the discount, and the amount discounted
WITH total_income_CTE AS (
SELECT DISTINCT order_id, order_total, discounted_total
FROM sales
)

SELECT SUM(order_total) AS total_before_discount, ROUND(SUM(discounted_total),2) as total_after_discount,
SUM(order_total) - ROUND(SUM(discounted_total),2) as discounted_amount
FROM total_income_CTE


-- We're done with SQL, let's move to Power BI to create the dashboard!
-- Note: Further analysis and insights might be done in Power BI


